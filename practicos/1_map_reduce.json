{"paragraphs":[{"text":"val baseDir=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/03_rdd_notebook\"\nprint(\"\"\"%html\n<center>\n    <h1>Programación Distribuida sobre Grandes Volúmenes de Datos</h1>\n</center>\n\n<br>\n\n<h3 style=\"text-align:center;\">\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    Facultad de Matemática Astronomía Física y Computación\n    </a>\n<br/>\n    <a href=\"http://www.unc.edu.ar\">\n    Universidad Nacional de Córdoba\n    </a>\n<br/>\n    <center>\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    <img src=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/comun/logo%20UNC%20FAMAF%202016.svg\" alt=\"Drawing\" style=\"width:50%;\"/>\n    </a>\n    </center>\n</h3>\n\n<h4 style=\"text-align:center;\"> Damián Barsotti  </h4>\n\n<p style=\"font-size:15px;\">\n    <br />\n        This work is licensed under a\n        <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n    <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">\n        <img alt=\"Creative Commons License\" style=\"border-width:0;vertical-align:middle;float:right\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" />\n    </a>\n</p>\n\"\"\")\n","dateUpdated":"2016-08-22T06:17:26-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":false,"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646961_-1791110000","id":"20160822-181726_882678609","result":{"code":"SUCCESS","type":"HTML","msg":"<center>\n    <h1>Programación Distribuida sobre Grandes Volúmenes de Datos</h1>\n</center>\n\n<br>\n\n<h3 style=\"text-align:center;\">\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    Facultad de Matemática Astronomía Física y Computación\n    </a>\n<br/>\n    <a href=\"http://www.unc.edu.ar\">\n    Universidad Nacional de Córdoba\n    </a>\n<br/>\n    <center>\n    <a href=\"http://www.famaf.unc.edu.ar\">\n    <img src=\"https://cs.famaf.unc.edu.ar/~damian/bigdata/curso/posgrado_optativa/lectivo/presentaciones/comun/logo%20UNC%20FAMAF%202016.svg\" alt=\"Drawing\" style=\"width:50%;\"/>\n    </a>\n    </center>\n</h3>\n\n<h4 style=\"text-align:center;\"> Damián Barsotti  </h4>\n\n<p style=\"font-size:15px;\">\n    <br />\n        This work is licensed under a\n        <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n    <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">\n        <img alt=\"Creative Commons License\" style=\"border-width:0;vertical-align:middle;float:right\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" />\n    </a>\n</p>\n"},"dateCreated":"2016-08-22T06:17:26-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1138"},{"text":"%md\n# Práctico 1 \n\n## MapReduce\n\nEn este práctico se desarrollarán ejercicios para implementar algunos algoritmos MapReduce. Además se practicará la construcción de programas en Scala.\nPara hacer el práctico tener en cuenta:\n* Se recomienda fuertemente haber hecho el tutorial de Scala.\n* Para correr los programa debe usar **[`Shift`]-[`Enter`]** o cliquear el triangulito arriba a la derecha de la celda (RUN).\n* Para hacer copy and paste desde el notebook seleccionar con **[`Ctrl`]-[flechitas]** y hacer **[`Ctrl`]-[`c`]** y **[`Ctrl`]-[`v`]**.\n\n","dateUpdated":"2016-08-22T06:17:26-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":false,"editorMode":"ace/mode/markdown","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646963_-1790340502","id":"20160822-181726_1132466334","result":{"code":"SUCCESS","type":"HTML","msg":"<h1>Práctico 1</h1>\n<h2>MapReduce</h2>\n<p>En este práctico se desarrollarán ejercicios para implementar algunos algoritmos MapReduce. Además se practicará la construcción de programas en Scala.\n<br  />Para hacer el práctico tener en cuenta:</p>\n<ul>\n<li>Se recomienda fuertemente haber hecho el tutorial de Scala.</li>\n<li>Para correr los programa debe usar <strong>[<code>Shift</code>]-[<code>Enter</code>]</strong> o cliquear el triangulito arriba a la derecha de la celda (RUN).</li>\n<li>Para hacer copy and paste desde el notebook seleccionar con <strong>[<code>Ctrl</code>]-[flechitas]</strong> y hacer <strong>[<code>Ctrl</code>]-[<code>c</code>]</strong> y <strong>[<code>Ctrl</code>]-[<code>v</code>]</strong>.</li>\n</ul>\n"},"dateCreated":"2016-08-22T06:17:26-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1139"},{"text":"%md\n### Implementación naif del patrón MapReduce\n\nA continuación se dará una implementación en Scala del patrón muy simple. La misma corre solo en una máquina, sin file system distribuido y solo nos servirá para practicar el uso del patrón.\nLea el código y trate de entenderlo. Comparelo también con la presentación en clase del tema. Cualquier duda consulte un docente.\n","dateUpdated":"2016-08-22T06:17:26-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":false,"editorMode":"ace/mode/markdown","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646963_-1790340502","id":"20160822-181726_901871987","result":{"code":"SUCCESS","type":"HTML","msg":"<h3>Implementación naif del patrón MapReduce</h3>\n<p>A continuación se dará una implementación en Scala del patrón muy simple. La misma corre solo en una máquina, sin file system distribuido y solo nos servirá para practicar el uso del patrón.\n<br  />Lea el código y trate de entenderlo. Comparelo también con la presentación en clase del tema. Cualquier duda consulte un docente.</p>\n"},"dateCreated":"2016-08-22T06:17:26-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1140"},{"text":"// Funcion map comun pero que devuelve lista de pares (clave,valor)\ndef elMap[Kin,Vin,Kout,Vout]\n    (datosIn: List[(Kin,Vin)])\n    (fmap : (Kin,Vin) => List[(Kout,Vout)])\n    : List[(Kout,Vout)]\n    = datosIn.flatMap(kv => fmap(kv._1,kv._2)) // Cannot use just f, something wierd with implicits\n\n// Agrupa los valores que tienen clave comun\ndef agrupa[Kout,Vout]\n    (kvs : List[(Kout,Vout)])\n    : Map[Kout,List[Vout]]\n    = kvs.groupBy(_._1).mapValues(_.unzip._2)\n\n//    = kvs.groupBy(_._1).mapValues(_.map(_.2))\n\n// Para cada clave aplico una operacion a su lista de valores\ndef reduce[Kout,Vout,VFin]\n    (kvss : Map[Kout,List[Vout]])\n    (freduce : (Kout,  List[Vout]) => VFin)\n    : List[VFin]\n    = kvss.map({case (k,vs) => freduce(k,vs)}).toList\n    // = kvss.map(_ => freduce(_._1, _._2)).toList\n\n//Junto todo\ndef mapReduce[Kin,Vin,Kout,Vout,VFin]\n    (datosIn: List[(Kin,Vin)])\n    (fmap : (Kin,Vin) => List[(Kout,Vout)])\n    (freduce : (Kout,  List[Vout]) => VFin)\n    : List[VFin]\n    = {\n        val resMap = elMap (datosIn) (fmap)\n        val resAgrupo  = agrupa(resMap)\n        val resReduce = reduce (resAgrupo) (freduce)\n        return resReduce\n    }","dateUpdated":"2016-09-08T03:51:09-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646963_-1790340502","id":"20160822-181726_64520531","result":{"code":"SUCCESS","type":"TEXT","msg":"elMap: [Kin, Vin, Kout, Vout](datosIn: List[(Kin, Vin)])(fmap: (Kin, Vin) => List[(Kout, Vout)])List[(Kout, Vout)]\nagrupa: [Kout, Vout](kvs: List[(Kout, Vout)])Map[Kout,List[Vout]]\nreduce: [Kout, Vout, VFin](kvss: Map[Kout,List[Vout]])(freduce: (Kout, List[Vout]) => VFin)List[VFin]\nmapReduce: [Kin, Vin, Kout, Vout, VFin](datosIn: List[(Kin, Vin)])(fmap: (Kin, Vin) => List[(Kout, Vout)])(freduce: (Kout, List[Vout]) => VFin)List[VFin]\n"},"dateCreated":"2016-08-22T06:17:26-0300","dateStarted":"2016-09-08T03:51:10-0300","dateFinished":"2016-09-08T03:52:06-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1141"},{"text":"%md\n### Pequeño ejemplo de uso\n\nA continuación se verá la implementación em MapReduce del algoritmo que encuentra la cantidad de apariciones de cada letra (visto en clase).\nPruebe eejcutarlo llamando a la función `countChar` con un `String` cualquiera.","dateUpdated":"2016-08-22T06:17:26-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":false,"editorMode":"ace/mode/markdown","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646963_-1790340502","id":"20160822-181726_459029532","result":{"code":"SUCCESS","type":"HTML","msg":"<h3>Pequeño ejemplo de uso</h3>\n<p>A continuación se verá la implementación em MapReduce del algoritmo que encuentra la cantidad de apariciones de cada letra (visto en clase).\n<br  />Pruebe eejcutarlo llamando a la función <code>countChar</code> con un <code>String</code> cualquiera.</p>\n"},"dateCreated":"2016-08-22T06:17:26-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1142"},{"text":"// Cuento cantidad de veces que aparece cada letra\n// ===============================================\ndef countChar (str: String) = {\n    val datos = str.toList.map(c => ((),c))\n    val fmap = (_ : Unit, c : Char) => List((c,1))\n    val freduce = (c: Char, vs: List[Int]) => (c,vs.fold (0) (_+_))\n    mapReduce (datos) (fmap) (freduce)\n}\n\ncountChar(\"Hola ULCHO. PLS!!!\")","dateUpdated":"2016-08-22T07:11:36-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646963_-1790340502","id":"20160822-181726_1478216457","result":{"code":"SUCCESS","type":"TEXT","msg":"countChar: (str: String)List[(Char, Int)]\nres17: List[(Char, Int)] = List((.,1), (U,1), (!,3), (a,1), ( ,2), (L,2), (l,1), (P,1), (C,1), (H,2), (O,1), (o,1), (S,1))\n"},"dateCreated":"2016-08-22T06:17:26-0300","dateStarted":"2016-08-22T07:11:36-0300","dateFinished":"2016-08-22T07:11:37-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1143"},{"text":"%md\n### Ejercicio ~\n\nEn la celda siguiente modifique el programa anterior para que tome un archivo en vez de un string.\nLa idea es que el `map` trabaje sobre cada linea de texto (no sobre cada caracter).\nA continuación se muestra un esqueleto del programa que debe completar programando las funciones `fmap` y `freduce`:\n","dateUpdated":"2016-08-22T06:17:26-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":false,"editorMode":"ace/mode/markdown","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646963_-1790340502","id":"20160822-181726_1722760088","result":{"code":"SUCCESS","type":"HTML","msg":"<h3>Ejercicio ~</h3>\n<p>En la celda siguiente modifique el programa anterior para que tome un archivo en vez de un string.\n<br  />La idea es que el <code>map</code> trabaje sobre cada linea de texto (no sobre cada caracter).\n<br  />A continuación se muestra un esqueleto del programa que debe completar programando las funciones <code>fmap</code> y <code>freduce</code>:</p>\n"},"dateCreated":"2016-08-22T06:17:26-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1144"},{"text":"def countCharFile (filePath: String) = {\n    \nimport scala.io.Source\n\n    val lines : List[String] = Source.fromFile(filePath).getLines.toList\n    val datos = lines.map(l => ((),l))\n    val fmap = (_ : Unit, l : String) => l.map(c => (c, 1)).toList\n    val freduce = (c: Char, vs: List[Int]) => (c, vs.fold (0) (_+_))\n    mapReduce (datos) (fmap) (freduce)\n}\n\ncountCharFile(\"/Users/crscardellino/Documents/Posgrado/Cursado/BigData/test.txt\")","dateUpdated":"2016-08-22T07:19:57-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646963_-1790340502","id":"20160822-181726_557513735","result":{"code":"SUCCESS","type":"TEXT","msg":"countCharFile: (filePath: String)List[(Char, Int)]\nres23: List[(Char, Int)] = List((u,2), (!,1), (a,1), (i,1), ( ,2), (L,2), (g,1), (l,2), (H,1), (c,2), (h,2), (o,3))\n"},"dateCreated":"2016-08-22T06:17:26-0300","dateStarted":"2016-08-22T07:19:57-0300","dateFinished":"2016-08-22T07:19:58-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1145"},{"text":"%md\n### Ejercicio ~ (wordCount)\n\nHacer un programa que calcule la cantidad de veces que aparece cada palabra (no vacía) en un archivo.\nA continuación se muestra un esqueleto del programa que debe completar programando las funciones `fmap` y `freduce`.\n\n#### Ayuda\n\n* Para dividir un `String` en palabras se puede usar el método `split`.\n* Para filtrar elementos de una lista se puede usar el método `filter`. \n* Para ver si un `String` no es vacío se puede usar `! _.isEmpty`","dateUpdated":"2016-08-22T06:17:26-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":false,"editorMode":"ace/mode/markdown","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646963_-1790340502","id":"20160822-181726_1543280864","result":{"code":"SUCCESS","type":"HTML","msg":"<h3>Ejercicio ~ (wordCount)</h3>\n<p>Hacer un programa que calcule la cantidad de veces que aparece cada palabra (no vacía) en un archivo.\n<br  />A continuación se muestra un esqueleto del programa que debe completar programando las funciones <code>fmap</code> y <code>freduce</code>.</p>\n<h4>Ayuda</h4>\n<ul>\n<li>Para dividir un <code>String</code> en palabras se puede usar el método <code>split</code>.</li>\n<li>Para filtrar elementos de una lista se puede usar el método <code>filter</code>.</li>\n<li>Para ver si un <code>String</code> no es vacío se puede usar <code>! _.isEmpty</code></li>\n</ul>\n"},"dateCreated":"2016-08-22T06:17:26-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1146"},{"text":"def wordCount (filePath: String) = {\n\nimport scala.io.Source\n\n    val lines : List[String] = Source.fromFile(filePath).getLines.toList\n    val datos = lines.map(l => ((),l))\n\n    val fmap = (_ : Unit, l : String) => l.split(\" \").filter(!_.isEmpty).map(w => (w, 1)).toList\n    val freduce = (w: String, vs: List[Int]) => (w, vs.fold (0) (_+_))\n\n    mapReduce (datos) (fmap) (freduce)\n}\n\nwordCount(\"/Users/crscardellino/Documents/Posgrado/Cursado/BigData/test.txt\")","dateUpdated":"2016-08-22T07:25:41-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646963_-1790340502","id":"20160822-181726_1572426517","result":{"code":"SUCCESS","type":"TEXT","msg":"wordCount: (filePath: String)List[(String, Int)]\nres26: List[(String, Int)] = List((gil!,1), (Hola,1), (Lucho,2))\n"},"dateCreated":"2016-08-22T06:17:26-0300","dateStarted":"2016-08-22T07:25:41-0300","dateFinished":"2016-08-22T07:25:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1147"},{"text":"%md\n### Ejercicio ~ (amigos en común)\n\nDada una lista de tuplas, donde el primer elemento es una persona y el segundo una lista de sus amigos, hacer un programa con `mapReduce` que devuelve la lista de amigos en común de todos los pares de personas posibles.\nLa lista de amigos se almacena de la siguiente forma:\n```scala\nval amigosDe = List(  (\"A\", List(\"B\", \"C\", \"D\"))\n                    , (\"B\", List(\"A\", \"C\", \"D\", \"E\"))\n                    , (\"C\", List(\"A\", \"B\", \"D\", \"E\"))\n                    , (\"D\", List(\"A\", \"B\", \"C\", \"E\"))\n                    , (\"E\", List(\"B\", \"C\", \"D\"))      )\n```\nVer que la relación de amistad tiene que ser simétrica.\n#### Ayuda\nPara cada par `(p,ams)` de la lista de entrada la función `map` puede devolver todas las tuplas posible `({p,am},ams)` donde `am` es un elemento de `ams`.\nVer que en este deben aparecer exactamente dos tuplas cuyos primeros elementos (`{p,am}`) son iguales.\nA partir de esta observación los amigos en común son la intersección de las segundas componentes de ambas tuplas.\nA continuación se da un esqueleto del programa a completar:\n","dateUpdated":"2016-08-22T06:17:26-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":false,"editorMode":"ace/mode/markdown","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646964_-1792264247","id":"20160822-181726_1121308865","result":{"code":"SUCCESS","type":"HTML","msg":"<h3>Ejercicio ~ (amigos en común)</h3>\n<p>Dada una lista de tuplas, donde el primer elemento es una persona y el segundo una lista de sus amigos, hacer un programa con <code>mapReduce</code> que devuelve la lista de amigos en común de todos los pares de personas posibles.\n<br  />La lista de amigos se almacena de la siguiente forma:</p>\n<pre><code class=\"scala\">val amigosDe = List(  (\"A\", List(\"B\", \"C\", \"D\"))\n                    , (\"B\", List(\"A\", \"C\", \"D\", \"E\"))\n                    , (\"C\", List(\"A\", \"B\", \"D\", \"E\"))\n                    , (\"D\", List(\"A\", \"B\", \"C\", \"E\"))\n                    , (\"E\", List(\"B\", \"C\", \"D\"))      )\n</code></pre>\n<p>Ver que la relación de amistad tiene que ser simétrica.</p>\n<h4>Ayuda</h4>\n<p>Para cada par <code>(p,ams)</code> de la lista de entrada la función <code>map</code> puede devolver todas las tuplas posible <code>({p,am},ams)</code> donde <code>am</code> es un elemento de <code>ams</code>.\n<br  />Ver que en este deben aparecer exactamente dos tuplas cuyos primeros elementos (<code>{p,am}</code>) son iguales.\n<br  />A partir de esta observación los amigos en común son la intersección de las segundas componentes de ambas tuplas.\n<br  />A continuación se da un esqueleto del programa a completar:</p>\n"},"dateCreated":"2016-08-22T06:17:26-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1148"},{"text":"def amigosEnComun(ade: List[(String,List[String])]) = {\n    val fmap = (p : String, ams : List[String]) => ams.map(am => (Set(p, am), ams))\n    val freduce = (ps: Set[String], ams: List[List[String]]) => (ps, ams.reduce (_.intersect(_)))\n\n    mapReduce (ade) (fmap) (freduce)\n}\n\nval amigosDe = List(  (\"A\", List(\"B\", \"C\", \"D\"))\n                    , (\"B\", List(\"A\", \"C\", \"D\", \"E\"))\n                    , (\"C\", List(\"A\", \"B\", \"D\", \"E\"))\n                    , (\"D\", List(\"A\", \"B\", \"C\", \"E\"))\n                    , (\"E\", List(\"B\", \"C\", \"D\"))\n                    )\n\namigosEnComun(amigosDe)\n","dateUpdated":"2016-08-22T07:58:38-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646964_-1792264247","id":"20160822-181726_888784472","result":{"code":"SUCCESS","type":"TEXT","msg":"amigosEnComun: (ade: List[(String, List[String])])List[(Set[String], List[String])]\namigosDe: List[(String, List[String])] = List((A,List(B, C, D)), (B,List(A, C, D, E)), (C,List(A, B, D, E)), (D,List(A, B, C, E)), (E,List(B, C, D)))\nres34: List[(Set[String], List[String])] = List((Set(A, C),List(B, D)), (Set(C, D),List(A, B, E)), (Set(D, E),List(B, C)), (Set(A, D),List(B, C)), (Set(A, B),List(C, D)), (Set(B, E),List(C, D)), (Set(B, D),List(A, C, E)), (Set(B, C),List(A, D, E)), (Set(C, E),List(B, D)))\n"},"dateCreated":"2016-08-22T06:17:26-0300","dateStarted":"2016-08-22T07:58:38-0300","dateFinished":"2016-08-22T07:58:38-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1149"},{"text":"%md\n### Ejercicio ~ (word co-ocurrencia)\nEn el siguiente ejercicio hay que construir la matriz de *co-ocurrencia* de palabras en una misma linea. Esta es una matriz `n*n` donde `n` es el número de palabras (sin repetición) en un texto. Para cada par de palabres (fila y columna de la matriz) se cuenta la cantidad de veces que ocurren ambas en una misma linea.\n\n####Ayuda\nSe puede hacer que la función `fmap` devuelva una lista de pares depalabras en una misma linea con un contador igual a `1`. Por ejemplo, en la linea `w1 w2 w3 w1` la función produciría: \n`(w1,w2):1, (w1, w3):1, (w2:w1):1, (w2,w3):1, (w2:w1):1, (w3,w1):1, (w3:w2):1, (w3,w1):1, (w1, w2):1, (w1, w3):1, (w1,w1):1`\n(ver que pasa si se repite la palabra una o más veces)\nLa función `freduce` recolectaría estos valores para llenar cada elemento de la matriz.\n\nA continuación se da un esqueleto del programa a completar:","dateUpdated":"2016-08-22T06:17:26-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":false,"editorMode":"ace/mode/markdown","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646964_-1792264247","id":"20160822-181726_192771007","result":{"code":"SUCCESS","type":"HTML","msg":"<h3>Ejercicio ~ (word co-ocurrencia)</h3>\n<p>En el siguiente ejercicio hay que construir la matriz de <em>co-ocurrencia</em> de palabras en una misma linea. Esta es una matriz <code>n*n</code> donde <code>n</code> es el número de palabras (sin repetición) en un texto. Para cada par de palabres (fila y columna de la matriz) se cuenta la cantidad de veces que ocurren ambas en una misma linea.</p>\n<h4>Ayuda</h4>\n<p>Se puede hacer que la función <code>fmap</code> devuelva una lista de pares depalabras en una misma linea con un contador igual a <code>1</code>. Por ejemplo, en la linea <code>w1 w2 w3 w1</code> la función produciría:\n<br  /><code>(w1,w2):1, (w1, w3):1, (w2:w1):1, (w2,w3):1, (w2:w1):1, (w3,w1):1, (w3:w2):1, (w3,w1):1, (w1, w2):1, (w1, w3):1, (w1,w1):1</code>\n<br  />(ver que pasa si se repite la palabra una o más veces)\n<br  />La función <code>freduce</code> recolectaría estos valores para llenar cada elemento de la matriz.</p>\n<p>A continuación se da un esqueleto del programa a completar:</p>\n"},"dateCreated":"2016-08-22T06:17:26-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1150"},{"text":"def wordCoOcurrence (filePath: String) = {\n    import scala.io.Source\n    \n    val lines : List[String] = Source.fromFile(filePath).getLines.toList\n    val datos = lines.map(l => ((),l))\n\n    val fmap = (_ : Unit, l : String) => {\n        val splitted_line = l.split(\" \").filter(_.nonEmpty)\n        splitted_line.zipWithIndex.flatMap(word => splitted_line.drop(word._2).map(wd => (List(word._1, wd).sorted, 1))).toList\n    }\n    val freduce = (w: List[String], vs: List[Int]) => (w, vs.fold (0) (_+_))\n\n    mapReduce (datos) (fmap) (freduce)\n}\n\nwordCoOcurrence(\"/Users/crscardellino/Documents/Posgrado/Cursado/BigData/pruebas/test.txt\")","dateUpdated":"2016-09-13T02:46:48-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646964_-1792264247","id":"20160822-181726_483108926","result":{"code":"SUCCESS","type":"TEXT","msg":"wordCoOcurrence: (filePath: String)List[(List[String], Int)]\nres15: List[(List[String], Int)] = List((List(ladra, ladra),1), (List(al, loro),1), (List(el, y),2), (List(imita, perro),1), (List(el, perro),2), (List(el, nada),1), (List(come, pescado),1), (List(imita, y),1), (List(ladra, loro),1), (List(al, perro),1), (List(perro, y),1), (List(pescado, pescado),1), (List(imita, ladra),1), (List(al, gato),1), (List(come, come),1), (List(el, pescado),1), (List(pez, pez),1), (List(imita, loro),1), (List(gato, y),1), (List(gato, loro),1), (List(ladra, y),1), (List(al, el),2), (List(loro, y),1), (List(nada, pez),1), (List(loro, loro),1), (List(come, gato),1), (List(el, gato),3), (List(imita, imita),1), (List(perro, perro),1), (List(al, ladra),1), (List(el, pez),1), (List(gato, pescado),1), (List(gato, ladra),1), (List(ladra, perro),1), (List(gato, imita),..."},"dateCreated":"2016-08-22T06:17:26-0300","dateStarted":"2016-09-08T03:59:41-0300","dateFinished":"2016-09-08T03:59:43-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1151"},{"title":"FIN","text":"println(\"\"\"%html\n<script>\n    var heads = document.getElementsByTagName('h3');\n    var numHeads = heads.length;\n    var inner = \"\";\n    var i = 0;\n    var j = 0;\n    while (i < numHeads){\n        inner = heads[i].innerHTML;\n        if (inner.search(\"~\") != -1 ) {\n            j++;\n            heads[i].innerHTML = inner.replace(\"~\",\"\"+j);\n        }\n        i++\n    }\n</script>\n\"\"\")","dateUpdated":"2016-08-22T06:17:26-0300","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":false,"editorMode":"ace/mode/scala","editorHide":true,"tableHide":true,"title":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1471900646964_-1792264247","id":"20160822-181726_1886662846","result":{"code":"SUCCESS","type":"HTML","msg":"<script>\n    var heads = document.getElementsByTagName('h3');\n    var numHeads = heads.length;\n    var inner = \"\";\n    var i = 0;\n    var j = 0;\n    while (i < numHeads){\n        inner = heads[i].innerHTML;\n        if (inner.search(\"~\") != -1 ) {\n            j++;\n            heads[i].innerHTML = inner.replace(\"~\",\"\"+j);\n        }\n        i++\n    }\n</script>\n\n"},"dateCreated":"2016-08-22T06:17:26-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1152"}],"name":"Práctico 1 - MapReduce","id":"2BW9XWT8E","angularObjects":{"2BVNPSW9V":[],"2BTMC7TKA":[],"2BSRRZ7M4":[],"2BSVVSEN7":[],"2BV1K682G":[],"2BVTN1H7Q":[],"2BVCFHS2D":[],"2BWBXGZP1":[],"2BSWUK1NJ":[],"2BUNT31B1":[],"2BTYA3GWQ":[],"2BW6STQAT":[],"2BVMB1STV":[],"2BV59N5AU":[]},"config":{"looknfeel":"default"},"info":{}}